{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PySCSA - Semi-Classical Signal Analysis","text":"<p>PySCSA is a Python library for signal and image processing using Semi-Classical Signal Analysis (SCSA), a method inspired by quantum mechanics.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Adaptive Signal Decomposition: Signal-dependent basis functions that adapt to your data</li> <li>1D Signal Processing: Reconstruction and denoising of 1D signals</li> <li>2D Image Processing: Image reconstruction using separation of variables</li> <li>Automatic Optimization: C-SCSA for parameter optimization</li> <li>Windowed Processing: Efficient handling of large images</li> <li>Comprehensive Metrics: Built-in MSE, PSNR, SSIM calculations</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from pyscsa import SCSA1D\nimport numpy as np\n\n# Generate noisy signal\nx = np.linspace(-10, 10, 500)\nsignal = -2 * (1/np.cosh(x))**2\nnoisy = signal + 0.1 * np.random.randn(len(signal))\n\n# Denoise using SCSA\nscsa = SCSA1D(gmma=0.5)\nresult = scsa.filter_with_c_scsa(noisy)\n\nprint(f\"PSNR: {result.metrics['psnr']:.2f} dB\")\n</code></pre>"},{"location":"#why-scsa","title":"Why SCSA?","text":"<p>Unlike traditional methods that use fixed basis functions (like Fourier's sines/cosines or predefined wavelets), SCSA generates signal-dependent basis functions through eigenvalue decomposition of the Schr\u00f6dinger operator. This provides:</p> <ul> <li>Better Peak Preservation: Ideal for pulse-shaped signals</li> <li>Adaptive Resolution: Automatically adjusts to signal features</li> <li>Quantum-Inspired: Solid mathematical foundation from quantum mechanics</li> <li>Effective Denoising: Separates signal from noise naturally</li> </ul>"},{"location":"#applications","title":"Applications","text":"<ul> <li>Biomedical signal processing (ECG, arterial blood pressure)</li> <li>Magnetic Resonance Spectroscopy (MRS)</li> <li>Image denoising and enhancement</li> <li>Feature extraction for machine learning</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pyscsa\n</code></pre> <p>Or from source:</p> <pre><code>git clone https://github.com/boost-inria/pyscsa.git\ncd pyscsa\npip install -e .\n</code></pre>"},{"location":"#get-started","title":"Get Started","text":"<p>Check out our Quick Start Guide or dive into the API Reference.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use PySCSA in your research:</p> <pre><code>@software{pyscsa,\n  title = {PySCSA: Python Semi-Classical Signal Analysis Library},\n  author = {boost inria},\n  year = {2025},\n  url = {https://github.com/boost-inria/pyscsa}\n}\n</code></pre>"},{"location":"#license","title":"License","text":"<p>MIT License - see LICENSE for details.</p>"},{"location":"api/","title":"API Reference","text":"<p>Complete reference for PySCSA classes and functions.</p>"},{"location":"api/#core-classes","title":"Core Classes","text":""},{"location":"api/#scsa1d","title":"SCSA1D","text":"<p>1D Semi-Classical Signal Analysis for signal reconstruction and filtering.</p> <pre><code>from pyscsa import SCSA1D\n\nscsa = SCSA1D(gmma=0.5)\n</code></pre> <p>Parameters:</p> <ul> <li><code>gmma</code> (float, default=0.5): Gamma parameter controlling smoothness</li> </ul> <p>Methods:</p>"},{"location":"api/#reconstructsignal-h10-lambda_gnone","title":"<code>reconstruct(signal, h=1.0, lambda_g=None)</code>","text":"<p>Reconstruct 1D signal using SCSA.</p> <p>Parameters:</p> <ul> <li><code>signal</code> (ndarray): Input signal (auto-converted to positive)</li> <li><code>h</code> (float, default=1.0): Semi-classical parameter</li> <li><code>lambda_g</code> (float, optional): Lambda threshold (default=0)</li> </ul> <p>Returns:</p> <ul> <li><code>SCSAResult</code>: Contains:</li> <li><code>reconstructed</code> (ndarray): Reconstructed signal</li> <li><code>eigenvalues</code> (ndarray): Eigenvalues used</li> <li><code>eigenfunctions</code> (ndarray): Eigenfunctions matrix</li> <li><code>num_eigenvalues</code> (int): Number of eigenvalues</li> <li><code>metrics</code> (dict): MSE, RMSE, PSNR, SNR</li> </ul> <p>Example:</p> <pre><code>result = scsa.reconstruct(signal, h=1.0)\nprint(f\"MSE: {result.metrics['mse']:.6f}\")\nprint(f\"PSNR: {result.metrics['psnr']:.2f} dB\")\n</code></pre>"},{"location":"api/#filter_with_c_scsasignal-curvature_weight40-h_rangenone","title":"<code>filter_with_c_scsa(signal, curvature_weight=4.0, h_range=None)</code>","text":"<p>Filter signal using C-SCSA with automatic h optimization.</p> <p>Parameters:</p> <ul> <li><code>signal</code> (ndarray): Input noisy signal</li> <li><code>curvature_weight</code> (float, default=4.0): Weight for curvature penalty</li> <li><code>h_range</code> (tuple, optional): (h_min, h_max) for search range</li> </ul> <p>Returns:</p> <ul> <li><code>SCSAResult</code>: Result with <code>optimal_h</code> attribute set</li> </ul> <p>Example:</p> <pre><code>result = scsa.filter_with_c_scsa(noisy_signal)\nprint(f\"Optimal h: {result.optimal_h:.2f}\")\nprint(f\"PSNR: {result.metrics['psnr']:.2f} dB\")\n</code></pre>"},{"location":"api/#denoisenoisy_signal-kwargs","title":"<code>denoise(noisy_signal, **kwargs)</code>","text":"<p>Convenience method for signal denoising.</p> <p>Parameters:</p> <ul> <li><code>noisy_signal</code> (ndarray): Input noisy signal</li> <li><code>**kwargs</code>: Passed to <code>filter_with_c_scsa()</code></li> </ul> <p>Returns:</p> <ul> <li><code>ndarray</code>: Denoised signal (just the array, not SCSAResult)</li> </ul> <p>Example:</p> <pre><code>denoised = scsa.denoise(noisy_signal)\n</code></pre>"},{"location":"api/#scsa2d","title":"SCSA2D","text":"<p>2D Semi-Classical Signal Analysis for image reconstruction.</p> <pre><code>from pyscsa import SCSA2D\n\nscsa = SCSA2D(gmma=2.0)\n</code></pre> <p>Parameters:</p> <ul> <li><code>gmma</code> (float, default=2.0): Gamma parameter for 2D processing</li> </ul> <p>Methods:</p>"},{"location":"api/#reconstructimage-h100-lambda_g0","title":"<code>reconstruct(image, h=10.0, lambda_g=0)</code>","text":"<p>Reconstruct 2D image using separation of variables.</p> <p>Parameters:</p> <ul> <li><code>image</code> (ndarray): Input 2D image</li> <li><code>h</code> (float, default=10.0): Semi-classical parameter</li> <li><code>lambda_g</code> (float, default=0): Lambda threshold</li> </ul> <p>Returns:</p> <ul> <li><code>SCSAResult</code>: Contains reconstructed image and metrics</li> </ul> <p>Example:</p> <pre><code>result = scsa.reconstruct(image, h=5.0)\nreconstructed_image = result.reconstructed\n</code></pre>"},{"location":"api/#reconstruct_windowedimage-h10-window_size4-stride1-lambda_g0","title":"<code>reconstruct_windowed(image, h=1.0, window_size=4, stride=1, lambda_g=0)</code>","text":"<p>Reconstruct using windowed approach for large images.</p> <p>Parameters:</p> <ul> <li><code>image</code> (ndarray): Input 2D image</li> <li><code>h</code> (float, default=10.0): Semi-classical parameter</li> <li><code>window_size</code> (int, default=4): Size of sliding window</li> <li><code>stride</code> (int, default=1): Stride for window</li> <li><code>lambda_g</code> (float, default=0): Lambda threshold</li> </ul> <p>Returns:</p> <ul> <li><code>ndarray</code>: Reconstructed image</li> </ul> <p>Example:</p> <pre><code>result = scsa.reconstruct_windowed(\n    large_image, \n    h=1.0, \n    window_size=16, \n    stride=8\n)\n</code></pre>"},{"location":"api/#denoisenoisy_image-methodwindowed-kwargs","title":"<code>denoise(noisy_image, method='windowed', **kwargs)</code>","text":"<p>Denoise 2D image.</p> <p>Parameters:</p> <ul> <li><code>noisy_image</code> (ndarray): Input noisy image</li> <li><code>method</code> (str, default='windowed'): 'standard' or 'windowed'</li> <li><code>**kwargs</code>: Passed to reconstruction method</li> </ul> <p>Returns:</p> <ul> <li><code>ndarray</code>: Denoised image</li> </ul> <p>Example:</p> <pre><code>denoised = scsa.denoise(\n    noisy_image,\n    method='windowed',\n    window_size=16,\n    h=5.0\n)\n</code></pre>"},{"location":"api/#visualization","title":"Visualization","text":""},{"location":"api/#scsavisualizer","title":"SCSAVisualizer","text":"<p>Visualization utilities for SCSA results.</p> <pre><code>from pyscsa.visualization import SCSAVisualizer\n\nviz = SCSAVisualizer(figsize=(12, 8), style='default')\n</code></pre> <p>Parameters:</p> <ul> <li><code>figsize</code> (tuple, default=(10, 6)): Figure size (width, height)</li> <li><code>style</code> (str, default='default'): Matplotlib style</li> </ul> <p>Methods:</p>"},{"location":"api/#plot_1d_comparisonoriginal-reconstructed-noisynone-title-x_axisnone-metricsnone","title":"<code>plot_1d_comparison(original, reconstructed, noisy=None, title='', x_axis=None, metrics=None)</code>","text":"<p>Plot 1D signal comparison.</p> <p>Parameters:</p> <ul> <li><code>original</code> (ndarray): Original signal</li> <li><code>reconstructed</code> (ndarray): Reconstructed signal</li> <li><code>noisy</code> (ndarray, optional): Noisy signal</li> <li><code>title</code> (str): Plot title</li> <li><code>x_axis</code> (ndarray, optional): X-axis values</li> <li><code>metrics</code> (dict, optional): Metrics to display</li> </ul> <p>Returns:</p> <ul> <li><code>Figure</code>: Matplotlib figure</li> </ul> <p>Example:</p> <pre><code>fig = viz.plot_1d_comparison(\n    signal, \n    result.reconstructed, \n    noisy,\n    title=\"SCSA Denoising\",\n    metrics=result.metrics\n)\n</code></pre>"},{"location":"api/#plot_2d_comparisonoriginal-reconstructed-noisynone-title-cmapgray-metricsnone","title":"<code>plot_2d_comparison(original, reconstructed, noisy=None, title='', cmap='gray', metrics=None)</code>","text":"<p>Plot 2D image comparison.</p> <p>Parameters:</p> <ul> <li><code>original</code> (ndarray): Original image</li> <li><code>reconstructed</code> (ndarray): Reconstructed image</li> <li><code>noisy</code> (ndarray, optional): Noisy image</li> <li><code>title</code> (str): Plot title</li> <li><code>cmap</code> (str, default='gray'): Colormap</li> <li><code>metrics</code> (dict, optional): Metrics to display</li> </ul> <p>Returns:</p> <ul> <li><code>Figure</code>: Matplotlib figure</li> </ul>"},{"location":"api/#plot_eigenvalueseigenvalues-titleeigenvalue-spectrum","title":"<code>plot_eigenvalues(eigenvalues, title='Eigenvalue Spectrum')</code>","text":"<p>Plot eigenvalue spectrum.</p> <p>Parameters:</p> <ul> <li><code>eigenvalues</code> (ndarray): Eigenvalues array</li> <li><code>title</code> (str): Plot title</li> </ul> <p>Returns:</p> <ul> <li><code>Figure</code>: Matplotlib figure with linear and log scale</li> </ul>"},{"location":"api/#plot_eigenfunctionseigenfunctions-n_functions6-titleeigenfunctions","title":"<code>plot_eigenfunctions(eigenfunctions, n_functions=6, title='Eigenfunctions')</code>","text":"<p>Plot eigenfunctions.</p> <p>Parameters:</p> <ul> <li><code>eigenfunctions</code> (ndarray): Eigenfunctions matrix</li> <li><code>n_functions</code> (int, default=6): Number to plot</li> <li><code>title</code> (str): Plot title</li> </ul> <p>Returns:</p> <ul> <li><code>Figure</code>: Matplotlib figure</li> </ul>"},{"location":"api/#plot_parameter_sweepparam_values-metrics-param_nameparameter-optimal_valuenone","title":"<code>plot_parameter_sweep(param_values, metrics, param_name='parameter', optimal_value=None)</code>","text":"<p>Plot parameter sweep results.</p> <p>Parameters:</p> <ul> <li><code>param_values</code> (ndarray): Parameter values tested</li> <li><code>metrics</code> (dict): Dict of metric_name: values</li> <li><code>param_name</code> (str): Parameter name for label</li> <li><code>optimal_value</code> (float, optional): Mark optimal value</li> </ul> <p>Returns:</p> <ul> <li><code>Figure</code>: Matplotlib figure</li> </ul>"},{"location":"api/#save_figurefig-filename-dpi300-formatpng","title":"<code>save_figure(fig, filename, dpi=300, format='png')</code>","text":"<p>Save figure to file.</p> <p>Parameters:</p> <ul> <li><code>fig</code> (Figure): Matplotlib figure</li> <li><code>filename</code> (str): Output filename</li> <li><code>dpi</code> (int, default=300): Resolution</li> <li><code>format</code> (str, default='png'): File format</li> </ul>"},{"location":"api/#utility-functions","title":"Utility Functions","text":""},{"location":"api/#signal-generation","title":"Signal Generation","text":"<pre><code>from pyscsa.utils import SignalGenerator\n</code></pre> <p>Methods:</p> <ul> <li><code>SignalGenerator.sech_squared(x)</code>: Generate sech\u00b2 signal</li> <li><code>SignalGenerator.gaussian(x, sigma=1.0)</code>: Gaussian signal</li> <li><code>SignalGenerator.double_well(x, separation=3, depth=50)</code>: Double-well potential</li> </ul>"},{"location":"api/#noise-and-metrics","title":"Noise and Metrics","text":"<pre><code>from pyscsa.utils import add_noise, calculate_mse, calculate_psnr\n</code></pre>"},{"location":"api/#add_noisesignal-snr_db-seednone","title":"<code>add_noise(signal, snr_db, seed=None)</code>","text":"<p>Add Gaussian noise to signal.</p> <p>Parameters:</p> <ul> <li><code>signal</code> (ndarray): Input signal</li> <li><code>snr_db</code> (float): Desired SNR in dB</li> <li><code>seed</code> (int, optional): Random seed</li> </ul> <p>Returns:</p> <ul> <li><code>ndarray</code>: Noisy signal</li> </ul>"},{"location":"api/#calculate_mseoriginal-reconstructed","title":"<code>calculate_mse(original, reconstructed)</code>","text":"<p>Calculate Mean Squared Error.</p> <p>Returns: float</p>"},{"location":"api/#calculate_psnroriginal-reconstructed","title":"<code>calculate_psnr(original, reconstructed)</code>","text":"<p>Calculate Peak Signal-to-Noise Ratio.</p> <p>Returns: float (dB)</p>"},{"location":"api/#calculate_ssimoriginal-reconstructed","title":"<code>calculate_ssim(original, reconstructed)</code>","text":"<p>Calculate Structural Similarity Index.</p> <p>Returns: float [0, 1]</p>"},{"location":"api/#data-classes","title":"Data Classes","text":""},{"location":"api/#scsaresult","title":"SCSAResult","text":"<p>Result container returned by SCSA methods.</p> <p>Attributes:</p> <ul> <li><code>reconstructed</code> (ndarray): Reconstructed signal/image</li> <li><code>eigenvalues</code> (ndarray): Eigenvalues used</li> <li><code>eigenfunctions</code> (ndarray): Eigenfunctions matrix</li> <li><code>num_eigenvalues</code> (int): Number of eigenvalues</li> <li><code>optimal_h</code> (float, optional): Optimal h value (if computed)</li> <li><code>metrics</code> (dict): Performance metrics</li> </ul> <p>Example:</p> <pre><code>result = scsa.reconstruct(signal, h=1.0)\nprint(result.reconstructed.shape)\nprint(result.num_eigenvalues)\nprint(result.metrics)\n</code></pre>"},{"location":"api/#complete-example","title":"Complete Example","text":"<pre><code>from pyscsa import SCSA1D, SCSA2D\nfrom pyscsa.visualization import SCSAVisualizer\nfrom pyscsa.utils import add_noise\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 1D Example\nx = np.linspace(-10, 10, 500)\nsignal = np.exp(-x**2)\nnoisy = add_noise(signal, snr_db=15, seed=42)\n\nscsa1d = SCSA1D(gmma=0.5)\nresult = scsa1d.filter_with_c_scsa(noisy)\n\nviz = SCSAVisualizer()\nfig = viz.plot_1d_comparison(signal, result.reconstructed, noisy)\nplt.show()\n\n# 2D Example\nimage = np.random.rand(100, 100)\nnoisy_image = add_noise(image, snr_db=20, seed=42)\n\nscsa2d = SCSA2D(gmma=2.0)\ndenoised = scsa2d.denoise(\n    noisy_image, \n    method='windowed',\n    window_size=16, \n    h=5.0\n)\n\nfig = viz.plot_2d_comparison(image, denoised, noisy_image)\nplt.show()\n</code></pre> <p>For more details, see ReadTheDocs</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome contributions!</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<pre><code>git clone https://github.com/boost-inria/pyscsa.git\ncd pyscsa\npip install -e \".[dev]\"\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code>python -m pytest tests/ -v\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow PEP 8</li> <li>Add tests for new features</li> <li>Update documentation</li> </ul>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Make changes with tests</li> <li>Submit PR with description</li> </ol>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#advanced-1d-signal-processing","title":"Advanced 1D Signal Processing","text":""},{"location":"examples/#parameter-sweep-analysis","title":"Parameter Sweep Analysis","text":"<pre><code>from pyscsa import SCSA1D\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Generate signal\nx = np.linspace(-10, 10, 300)\nsignal = np.exp(-x**2)\nnoisy = signal + 0.1 * np.random.randn(len(signal))\n\n# Sweep gamma values\ngammas = np.linspace(0.1, 5.0, 20)\nmse_values = []\npsnr_values = []\n\nfor gmma in gammas:\n    scsa = SCSA1D(gmma=gmma)\n    result = scsa.reconstruct(noisy, h=1.0)\n    mse_values.append(result.metrics['mse'])\n    psnr_values.append(result.metrics['psnr'])\n\n# Plot results\nfig, axes = plt.subplots(1, 2, figsize=(12, 4))\naxes[0].plot(gammas, mse_values, 'o-')\naxes[0].set_xlabel('Gamma')\naxes[0].set_ylabel('MSE')\naxes[1].plot(gammas, psnr_values, 'o-')\naxes[1].set_xlabel('Gamma')\naxes[1].set_ylabel('PSNR (dB)')\nplt.show()\n</code></pre>"},{"location":"examples/#multi-peak-signal-reconstruction","title":"Multi-Peak Signal Reconstruction","text":"<pre><code>from pyscsa import SCSA1D\nfrom pyscsa.utils import SignalGenerator, add_noise\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create complex signal\nx = np.linspace(-10, 10, 500)\nsignal = (SignalGenerator.sech_squared(x - 3) + \n          SignalGenerator.sech_squared(x + 3) + \n          0.5 * SignalGenerator.gaussian(x, sigma=1.5))\n\n# Add noise\nnoisy = add_noise(signal, snr_db=10, seed=42)\n\n# Test different gamma values\nfig, axes = plt.subplots(2, 2, figsize=(14, 10))\nfor idx, gmma in enumerate([0.1, 0.5, 1.0, 2.0]):\n    ax = axes[idx // 2, idx % 2]\n    scsa = SCSA1D(gmma=gmma)\n    result = scsa.filter_with_c_scsa(noisy)\n\n    ax.plot(x, signal, 'k-', label='Original', linewidth=2)\n    ax.plot(x, noisy, 'gray', alpha=0.3, label='Noisy')\n    ax.plot(x, result.reconstructed, 'r--', label=f'SCSA (\u03b3={gmma})', linewidth=2)\n    ax.set_title(f'gamma={gmma}')\n    ax.legend()\n    ax.grid(True)\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"examples/#ecg-signal-denoising","title":"ECG Signal Denoising","text":"<pre><code>from pyscsa import SCSA1D\nfrom pyscsa.visualization import SCSAVisualizer\nimport numpy as np\n\n# Simulate ECG-like signal\nt = np.linspace(0, 10, 1000)\necg = (np.sin(2 * np.pi * 1.2 * t) + \n       0.5 * np.sin(2 * np.pi * 2.4 * t))\n\n# Add noise\nnoisy_ecg = ecg + 0.1 * np.random.randn(len(t))\n\n# Denoise\nscsa = SCSA1D(gmma=0.3)\nresult = scsa.filter_with_c_scsa(noisy_ecg)\n\n# Visualize\nviz = SCSAVisualizer()\nfig = viz.plot_1d_comparison(ecg, result.reconstructed, noisy_ecg, x_axis=t)\nprint(f\"SNR improvement: {result.metrics['snr']:.2f} dB\")\n</code></pre>"},{"location":"examples/#advanced-2d-image-processing","title":"Advanced 2D Image Processing","text":""},{"location":"examples/#large-image-processing","title":"Large Image Processing","text":"<pre><code>from pyscsa import SCSA2D\nimport numpy as np\n\n# Create large image\nsize = 256\nx = np.linspace(-10, 10, size)\ny = np.linspace(-10, 10, size)\nX, Y = np.meshgrid(x, y)\nimage = np.exp(-(X**2 + Y**2) / 10)\n\n# Add noise\nnoisy_image = image + 0.1 * np.random.randn(*image.shape)\n\n# Process with windowed approach\nscsa = SCSA2D(gmma=2.0)\ndenoised = scsa.denoise(\n    noisy_image,\n    method='windowed',\n    window_size=16,\n    h=5.0\n)\n</code></pre>"},{"location":"examples/#windowed-processing-with-different-sizes","title":"Windowed Processing with Different Sizes","text":"<pre><code>from pyscsa import SCSA2D\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create complex pattern\nsize = 256\nx = np.linspace(-10, 10, size)\ny = np.linspace(-10, 10, size)\nX, Y = np.meshgrid(x, y)\nimage = np.exp(-(X**2 + Y**2) / 10) * np.cos(X) * np.sin(Y)\nnoisy_image = image + 0.05 * np.random.randn(*image.shape)\n\n# Test different window sizes\nscsa = SCSA2D(gmma=2.0)\nresults = {}\n\nfor ws in [8, 16, 32]:\n    denoised = scsa.denoise(\n        noisy_image,\n        method='windowed',\n        window_size=ws,\n        h=5.0,\n        overlap=ws//2\n    )\n    results[ws] = denoised\n\n# Display\nfig, axes = plt.subplots(2, 2, figsize=(12, 12))\naxes = axes.ravel()\naxes[0].imshow(image, cmap='gray')\naxes[0].set_title('Original')\n\nfor idx, (ws, result) in enumerate(results.items(), 1):\n    axes[idx].imshow(result, cmap='gray')\n    axes[idx].set_title(f'Window size = {ws}')\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"examples/#comparison-with-other-methods","title":"Comparison with Other Methods","text":"<pre><code>from pyscsa import SCSA2D\nfrom pyscsa.utils import calculate_psnr, calculate_ssim\nfrom scipy.ndimage import gaussian_filter, median_filter\nimport numpy as np\n\n# Create test image\nx = np.linspace(-5, 5, 128)\ny = np.linspace(-5, 5, 128)\nX, Y = np.meshgrid(x, y)\nimage = np.exp(-(X**2 + Y**2) / 4)\nnoisy = image + 0.05 * np.random.randn(*image.shape)\n\n# SCSA\nscsa = SCSA2D(gmma=2.0)\nscsa_result = scsa.denoise(noisy, method='windowed', window_size=16, h=5.0)\n\n# Gaussian filter\ngaussian_result = gaussian_filter(noisy, sigma=1.0)\n\n# Median filter\nmedian_result = median_filter(noisy, size=3)\n\n# Compare\nmethods = {\n    'SCSA': scsa_result,\n    'Gaussian': gaussian_result,\n    'Median': median_result\n}\n\nprint(\"Method Comparison:\")\nprint(\"-\" * 50)\nfor name, result in methods.items():\n    psnr = calculate_psnr(image, result)\n    ssim = calculate_ssim(image, result)\n    print(f\"{name:10s} | PSNR: {psnr:6.2f} dB | SSIM: {ssim:.4f}\")\n</code></pre>"},{"location":"examples/#batch-processing","title":"Batch Processing","text":""},{"location":"examples/#processing-multiple-signals","title":"Processing Multiple Signals","text":"<pre><code>from pyscsa import SCSA1D\nimport numpy as np\nimport pandas as pd\n\n# Generate test signals\nx = np.linspace(-10, 10, 200)\nsignals = {\n    'exp': np.exp(-x**2),\n    'sech': 1 / np.cosh(x),\n    'gaussian': np.exp(-x**2 / 2),\n}\n\n# Process batch\nscsa = SCSA1D(gmma=0.5)\nresults = []\n\nfor name, signal in signals.items():\n    noisy = signal + 0.1 * np.random.randn(len(signal))\n    result = scsa.filter_with_c_scsa(noisy)\n\n    results.append({\n        'signal': name,\n        'mse': result.metrics['mse'],\n        'psnr': result.metrics['psnr'],\n        'optimal_h': result.optimal_h\n    })\n\n# Create DataFrame\ndf = pd.DataFrame(results)\nprint(df)\ndf.to_csv('batch_results.csv', index=False)\n</code></pre>"},{"location":"examples/#custom-signal-generation","title":"Custom Signal Generation","text":"<pre><code>from pyscsa import SCSA1D\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef custom_chirp(x, f0=1, f1=10):\n    \"\"\"Chirp signal with varying frequency\"\"\"\n    t = (x - x.min()) / (x.max() - x.min())\n    freq = f0 + (f1 - f0) * t\n    phase = 2 * np.pi * np.cumsum(freq) / len(x)\n    return np.sin(phase)\n\n# Generate and denoise\nx = np.linspace(0, 10, 1000)\nsignal = custom_chirp(x)\nnoisy = signal + 0.1 * np.random.randn(len(signal))\n\nscsa = SCSA1D(gmma=0.5)\nresult = scsa.filter_with_c_scsa(noisy)\n\n# Plot\nplt.figure(figsize=(12, 4))\nplt.plot(x, signal, 'k-', label='Original', linewidth=2)\nplt.plot(x, noisy, 'gray', alpha=0.5, label='Noisy')\nplt.plot(x, result.reconstructed, 'r--', label='SCSA', linewidth=2)\nplt.legend()\nplt.title('Chirp Signal Denoising')\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"examples/#saving-and-loading-results","title":"Saving and Loading Results","text":"<pre><code>from pyscsa import SCSA1D\nimport numpy as np\nimport pickle\n\n# Process signal\nx = np.linspace(-10, 10, 200)\nsignal = np.exp(-x**2)\n\nscsa = SCSA1D(gmma=0.5)\nresult = scsa.reconstruct(signal, h=1.0)\n\n# Save arrays\nnp.save('reconstructed.npy', result.reconstructed)\nnp.save('eigenvalues.npy', result.eigenvalues)\nnp.save('eigenfunctions.npy', result.eigenfunctions)\n\n# Save complete result\nwith open('scsa_result.pkl', 'wb') as f:\n    pickle.dump(result, f)\n\n# Load later\nwith open('scsa_result.pkl', 'rb') as f:\n    loaded = pickle.load(f)\n\nprint(f\"Loaded PSNR: {loaded.metrics['psnr']:.2f} dB\")\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.7+</li> <li>NumPy &gt;= 1.19.0</li> <li>SciPy &gt;= 1.5.0</li> <li>scikit-learn &gt;= 0.23.0</li> <li>matplotlib &gt;= 3.2.0</li> <li>pandas &gt;= 1.1.0</li> </ul>"},{"location":"installation/#install-via-pip","title":"Install via pip","text":"<pre><code>pip install pyscsa\n</code></pre>"},{"location":"installation/#install-from-source","title":"Install from source","text":"<pre><code>git clone https://github.com/boost-inria/pyscsa.git\ncd pyscsa\npip install -e .\n</code></pre>"},{"location":"installation/#development-installation","title":"Development installation","text":"<p>For contributing or running tests:</p> <pre><code>pip install -e \".[dev]\"\n</code></pre> <p>This includes pytest, coverage tools, and formatting utilities.</p>"},{"location":"installation/#verify-installation","title":"Verify installation","text":"<pre><code>import pyscsa\nfrom pyscsa import SCSA1D\nimport numpy as np\n\nx = np.linspace(-10, 10, 100)\nsignal = np.exp(-x**2)\nscsa = SCSA1D(gmma=0.5)\nresult = scsa.reconstruct(signal, h=1.0)\n\nprint(f\"\u2713 Installation successful! MSE: {result.metrics['mse']:.6f}\")\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":"<p>Import errors: Install missing dependencies:</p> <pre><code>pip install numpy scipy scikit-learn matplotlib pandas\n</code></pre> <p>Version conflicts: Use a virtual environment:</p> <pre><code>python -m venv pyscsa_env\nsource pyscsa_env/bin/activate  # Windows: pyscsa_env\\Scripts\\activate\npip install pyscsa\n</code></pre>"},{"location":"interactive/","title":"Interactive SCSA Demo","text":"Signal Type: Gaussian Sech Double Well Chirp Method: Reconstruct (manual h) Filter with C-SCSA Denoise Gamma (\u03b3): 0.5 h parameter: 1.0 Noise: 0.10 \u23f3 Processing..."},{"location":"quickstart/","title":"Quick Start Guide","text":""},{"location":"quickstart/#basic-1d-signal-denoising","title":"Basic 1D Signal Denoising","text":"<pre><code>from pyscsa import SCSA1D\nimport numpy as np\n\n# Generate noisy signal\nx = np.linspace(-10, 10, 500)\nsignal = -2 * (1/np.cosh(x))**2\nnoisy = signal + 0.1 * np.random.randn(len(signal))\n\n# Denoise with automatic h optimization\nscsa = SCSA1D(gmma=0.5)\nresult = scsa.filter_with_c_scsa(noisy)\n\nprint(f\"Optimal h: {result.optimal_h:.2f}\")\nprint(f\"PSNR: {result.metrics['psnr']:.2f} dB\")\nprint(f\"MSE: {result.metrics['mse']:.6f}\")\n</code></pre>"},{"location":"quickstart/#manual-parameter-control","title":"Manual Parameter Control","text":"<pre><code>from pyscsa import SCSA1D\nimport numpy as np\n\nx = np.linspace(-10, 10, 200)\nsignal = np.exp(-x**2)\n\n# Reconstruct with specific h value\nscsa = SCSA1D(gmma=1.0)\nresult = scsa.reconstruct(signal, h=2.0)\n\nprint(f\"Eigenvalues: {len(result.eigenvalues)}\")\nprint(f\"MSE: {result.metrics['mse']:.6f}\")\n</code></pre>"},{"location":"quickstart/#2d-image-processing","title":"2D Image Processing","text":"<pre><code>from pyscsa import SCSA2D\nimport numpy as np\n\n# Create test image\nx = np.linspace(-5, 5, 100)\ny = np.linspace(-5, 5, 100)\nX, Y = np.meshgrid(x, y)f\nimage = np.exp(-(X**2 + Y**2) / 4)\n\n# Add noise\nnoisy_image = image + 0.1 * np.random.randn(*image.shape)\n\n# Denoise using windowed approach\nscsa = SCSA2D(gmma=2.0)\ndenoised = scsa.denoise(\n    noisy_image,\n    method='windowed',\n    window_size=10,\n    h=5.0\n)\n</code></pre>"},{"location":"quickstart/#visualization","title":"Visualization","text":"<pre><code>from pyscsa import SCSA1D\nfrom pyscsa.visualization import SCSAVisualizer\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Generate and process signal\nx = np.linspace(-10, 10, 200)\nsignal = np.exp(-x**2)\nnoisy = signal + 0.1 * np.random.randn(len(signal))\n\nscsa = SCSA1D(gmma=0.5)\nresult = scsa.filter_with_c_scsa(noisy)\n\n# Create visualizations\nviz = SCSAVisualizer(figsize=(12, 8))\n\n# Comparison plot\nfig = viz.plot_1d_comparison(\n    signal,\n    result.reconstructed,\n    noisy,\n    x_axis=x,\n    metrics=result.metrics,\n    title=\"SCSA Signal Reconstruction\"\n)\nplt.show()\n\n# Eigenvalue spectrum\nfig = viz.plot_eigenvalues(result.eigenvalues)\nplt.show()\n\n# Eigenfunctions\nfig = viz.plot_eigenfunctions(result.eigenfunctions, n_functions=6)\nplt.show()\n</code></pre>"},{"location":"quickstart/#working-with-real-data","title":"Working with Real Data","text":"<pre><code>from pyscsa import SCSA1D\nimport numpy as np\n\n# Load your data\ndata = np.loadtxt('signal.txt')\n\n# Process\nscsa = SCSA1D(gmma=0.5)\nresult = scsa.filter_with_c_scsa(data)\n\n# Save results\nnp.savetxt('denoised.txt', result.reconstructed)\n\n# Save metrics\nwith open('metrics.txt', 'w') as f:\n    for key, value in result.metrics.items():\n        f.write(f\"{key}: {value}\\n\")\n</code></pre>"},{"location":"quickstart/#parameter-selection-tips","title":"Parameter Selection Tips","text":"<p>For gmma (gamma):</p> <ul> <li>Start with <code>gmma=0.5</code> for most signals</li> <li>Use <code>gmma=0.1-0.3</code> for very noisy data</li> <li>Use <code>gmma=1.0-2.0</code> to preserve fine details</li> </ul> <p>For 2D window_size:</p> <ul> <li>Small images (&lt; 100\u00d7100): Use full SCSA (no windowing)</li> <li>Medium (100-500): <code>window_size=16-32</code></li> <li>Large (&gt; 500): <code>window_size=32-64</code></li> </ul> <p>Overlap: Set to <code>window_size // 2</code> for smooth blending</p>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Read the Theory to understand the mathematics</li> <li>Explore Examples for advanced use cases</li> <li>Check the API Reference for all available functions</li> </ul>"},{"location":"tests/","title":"Running Tests","text":""},{"location":"tests/#run-all-tests","title":"Run all tests","text":"<pre><code>python -m pytest tests/ -v\n</code></pre>"},{"location":"tests/#with-coverage","title":"With coverage","text":"<pre><code>python -m pytest tests/ --cov=pyscsa --cov-report=html\n</code></pre>"},{"location":"tests/#test-specific-module","title":"Test specific module","text":"<pre><code>python -m pytest tests/test_scsa1d.py -v\n</code></pre> <p>View coverage: <code>open htmlcov/index.html</code></p>"},{"location":"theory/","title":"Theoretical Background","text":""},{"location":"theory/#overview","title":"Overview","text":"<p>Semi-Classical Signal Analysis (SCSA) is a signal processing method inspired by quantum mechanics that interprets signals as potentials of a Schr\u00f6dinger operator. Unlike Fourier or wavelet transforms with fixed bases, SCSA generates signal-dependent basis functions through eigenvalue decomposition.</p>"},{"location":"theory/#mathematical-foundation","title":"Mathematical Foundation","text":""},{"location":"theory/#the-schrodinger-operator","title":"The Schr\u00f6dinger Operator","text":"<p>For a 1D signal \\(y(x) \\geq 0\\), SCSA constructs:</p> \\[ H_h(y)\\psi = -h^2 \\frac{d^2\\psi}{dx^2} - y(x)\\psi = \\lambda\\psi \\] <p>where:</p> <ul> <li>\\(h &gt; 0\\): semi-classical parameter</li> <li>\\(y(x)\\): signal as potential</li> <li>\\(\\lambda\\): eigenvalues</li> <li>\\(\\psi\\): eigenfunctions in \\(H^2(\\mathbb{R})\\)</li> </ul>"},{"location":"theory/#signal-requirements","title":"Signal Requirements","text":"<p>Must satisfy Faddeev class:</p> \\[ y \\in \\mathcal{B} = \\{y \\in L^1_1(\\mathbb{R}), \\, y(x) \\geq 0, \\, \\frac{\\partial^m y}{\\partial x^m} \\in L^1(\\mathbb{R}), \\, m = 1, 2\\} \\]"},{"location":"theory/#reconstruction-formula","title":"Reconstruction Formula","text":"\\[ y_h(x) = 4h \\sum_{n=1}^{N_h} \\kappa_{nh} \\psi_{nh}^2(x) \\] <p>where \\(\\lambda_{nh} = -\\kappa_{nh}^2\\) are negative eigenvalues with \\(\\kappa_{1h} &gt; \\kappa_{2h} &gt; \\cdots\\)</p>"},{"location":"theory/#semi-classical-properties","title":"Semi-Classical Properties","text":""},{"location":"theory/#convergence","title":"Convergence","text":"<p>As \\(h \\to 0\\):</p> <ol> <li>\\(N_h\\) increases</li> <li>\\(y_h \\to y\\)</li> <li>Asymptotic: \\(\\lim_{h \\to 0} h N_h = \\frac{1}{\\pi} \\int_{-\\infty}^{+\\infty} \\sqrt{y(x)} dx\\)</li> </ol>"},{"location":"theory/#eigenvalue-distribution","title":"Eigenvalue Distribution","text":"<p>Eigenvalues accumulate at regular signal values, providing adaptive frequency-like decomposition based on signal structure rather than fixed sinusoids.</p>"},{"location":"theory/#momentum-conservation","title":"Momentum Conservation","text":"\\[ \\lim_{h \\to 0} h \\sum_{n=1}^{N_h} \\kappa_{nh} = \\frac{1}{4} \\int_{-\\infty}^{+\\infty} y(x) dx \\] \\[ \\lim_{h \\to 0} h \\sum_{n=1}^{N_h} \\kappa_{nh}^3 = \\frac{3}{16} \\int_{-\\infty}^{+\\infty} y^2(x) dx \\]"},{"location":"theory/#key-parameters","title":"Key Parameters","text":""},{"location":"theory/#parameter-h","title":"Parameter h","text":"<p>Small h (\\(h \\to 0\\)): - More eigenvalues - Better approximation - May include noise - Higher cost</p> <p>Large h: - Fewer eigenvalues - Smoother result - Better noise suppression - Risk of over-smoothing</p> <p>Typical: \\(h \\in [0.5, 5.0]\\)</p>"},{"location":"theory/#parameter","title":"Parameter \u03b3","text":"<p>In \\(\\gamma = 1/h^2\\):</p> <ul> <li>Small \u03b3 (&lt; 1): Strong smoothing</li> <li>Large \u03b3 (&gt; 1): Detail preservation</li> </ul>"},{"location":"theory/#c-scsa-automatic-selection","title":"C-SCSA Automatic Selection","text":"<p>Optimizes \\(h\\) via:</p> \\[ J = \\|y_\\delta - y_h\\|^2_2 + \\mu \\int |k(t)| dt \\] <p>where \\(k(t) = \\frac{|y''_h(t)|}{(1 + y'_h(t)^2)^{3/2}}\\) is curvature.</p>"},{"location":"theory/#eigenfunction-characteristics","title":"Eigenfunction Characteristics","text":"<ol> <li>Ordering: Lower-order capture main features</li> <li>Oscillations: \\(n\\)-th has \\(n-1\\) zeros</li> <li>Localization: Concentrate around peaks</li> <li>Adaptivity: Adjust to signal structure</li> </ol>"},{"location":"theory/#2d-extension","title":"2D Extension","text":"<p>For images, separation of variables:</p> \\[ \\mathcal{L}_{2D} = -h^2 \\left(\\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}\\right) + V(x,y) \\] <p>Solved via: 1. 1D SCSA along rows 2. 1D SCSA along columns 3. Combine results</p>"},{"location":"theory/#windowed-processing","title":"Windowed Processing","text":"<p>For large images: 1. Divide into overlapping windows 2. Apply SCSA per window 3. Blend with weighted averaging</p>"},{"location":"theory/#comparison","title":"Comparison","text":"Method Basis Best For Fourier Fixed sinusoids Periodic signals Wavelets Pre-selected Multi-scale analysis SCSA Signal-dependent Pulses, transients"},{"location":"theory/#advantages","title":"Advantages","text":"<ol> <li>Adaptive basis functions</li> <li>Excellent peak preservation</li> <li>Physical interpretation</li> <li>Automatic optimization</li> <li>Robust to various noise types</li> </ol>"},{"location":"theory/#limitations","title":"Limitations","text":"<ol> <li>\\(O(N^3)\\) computational cost</li> <li>Parameter sensitivity</li> <li>Requires \\(y(x) \\geq 0\\)</li> <li>Boundary effects</li> </ol>"},{"location":"theory/#practical-guidelines","title":"Practical Guidelines","text":"<ul> <li>Smooth signals: \\(\\gamma \\in [0.5, 1.0]\\), \\(h \\in [1.0, 3.0]\\)</li> <li>Noisy signals: \\(\\gamma \\in [0.3, 0.5]\\), \\(h \\in [2.0, 5.0]\\)</li> <li>Detail preservation: \\(\\gamma \\in [1.0, 2.0]\\), \\(h \\in [0.5, 2.0]\\)</li> </ul> <p>Use <code>filter_with_optimal_h()</code> for automatic selection.</p>"},{"location":"theory/#references","title":"References","text":"<ul> <li>Laleg-Kirati et al. (2013): \"Semi-classical signal analysis\"</li> <li>Li &amp; Laleg-Kirati (2019): \"Signal denoising based on Schr\u00f6dinger operator\"</li> <li>Helffer &amp; Robert (1990): \"Riesz means and semi-classical limits\"</li> <li>Deift &amp; Trubowitz (1979): \"Inverse scattering on the line\"</li> </ul>"}]}